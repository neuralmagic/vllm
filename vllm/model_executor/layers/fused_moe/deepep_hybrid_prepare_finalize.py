# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: Copyright contributors to the vLLM project

import deep_ep
import torch

import vllm.model_executor.layers.fused_moe.modular_kernel as mk
from vllm.distributed.parallel_state import get_dp_group
from vllm.model_executor.layers.fused_moe.config import FusedMoEQuantConfig
from vllm.model_executor.layers.fused_moe.topk_weight_and_reduce import (
    TopKWeightAndReduceContiguous,
    TopKWeightAndReduceDelegate,
)
from vllm.model_executor.layers.fused_moe.utils import moe_kernel_quantize_input
from vllm.utils.math_utils import round_up


# Copied from DeepEP hybrid_ep_buffer.py
def indices_to_map(
    topk_ids: torch.Tensor,
    topk_weights: torch.Tensor,
    num_of_tokens: int,
    num_of_experts: int,
) -> tuple[torch.Tensor, torch.Tensor]:
    # Generate the routing map and the probs according to the topk_ids and topk_weights.
    routing_map = torch.zeros(
        num_of_tokens, num_of_experts, device="cuda", dtype=torch.bool
    )
    routing_map = routing_map.scatter(1, topk_ids.to(torch.int64), 1).bool()

    probs = torch.zeros(
        num_of_tokens, num_of_experts, device="cuda", dtype=torch.float32
    )
    probs = probs.scatter(1, topk_ids.to(torch.int64), topk_weights)

    return routing_map, probs


class DeepEPHybridPrepareAndFinalize(mk.FusedMoEPrepareAndFinalize):
    """
    Prepare/Finalize using DeepEP Hybrid kernels.
    """

    @staticmethod
    def maybe_roundup_layer_hidden_size(hidden_size: int, dtype: torch.dtype) -> int:
        # Round up hidden size so it is compatible with DeepEP Hybrid
        # kernels.
        alignment = 128
        return round_up(hidden_size, alignment)

    def __init__(
        self,
        buffer: deep_ep.HybridEPBuffer,
        num_dispatchers: int,
        dp_size: int,  # Needed?
        rank_expert_offset: int,
        num_local_experts: int,
    ):
        super().__init__()
        self.buffer = buffer
        self.num_dispatchers_ = num_dispatchers
        self.dp_size = dp_size
        self.rank_expert_offset = rank_expert_offset  # TODO: not needed
        self.handle = None
        self.expert_probs = None
        self.do_permute = False
        self.num_local_experts = num_local_experts

    def num_dispatchers(self) -> int:
        return self.num_dispatchers_

    def output_is_reduced(self) -> bool:
        return True

    @property
    def activation_format(self) -> mk.FusedMoEActivationFormat:
        return mk.FusedMoEActivationFormat.Standard

    def max_num_tokens_per_rank(self) -> int | None:
        return None

    def topk_indices_dtype(self) -> torch.dtype | None:
        return torch.int64

    def supports_async(self) -> bool:
        return False

    # Copied from DeepEP hybrid_ep_buffer.py
    def construct_handle(self, hidden_dim, num_of_tokens, num_of_experts, routing_map):
        config = self.buffer.update_template_config(
            hidden_dim=hidden_dim,
            max_num_of_tokens_per_rank=num_of_tokens,
        )

        global_routing_map = get_dp_group().all_gather(routing_map, dim=0)

        # Run the metadata preprocessing kernel.
        (
            sparse_to_dense_map,
            rdma_to_attn_map,
            attn_to_rdma_map,
            num_dispatched_tokens_tensor,
            local_expert_routing_map,
        ) = self.buffer.runtime.metadata_preprocessing(
            config=config,
            routing_map=global_routing_map,
            num_of_tokens_per_rank=num_of_tokens,
        )
        # Create the handle using the data generated by the preprocessing kernel.
        return (
            sparse_to_dense_map,
            rdma_to_attn_map,
            attn_to_rdma_map,
            num_dispatched_tokens_tensor,
            local_expert_routing_map,
            num_of_tokens,
            config,
        )

    def p(self, msg, force=False):
        if force:
            print(msg)

    def pp(self, msg, t, force=False):
        if False and force:  # noqa: SIM223
            print(
                f"{msg}[{self.rank_expert_offset}] = "
                f"{t.shape if t is not None else None}"
            )
        elif False or force:
            print(
                f"{msg}[{self.rank_expert_offset}] = "
                f"{t.shape if t is not None else None}\n{t}"
            )

    def create_new_topk_data(
        self,
        topk_ids,
        topk_weights,
    ) -> tuple[torch.Tensor, torch.Tensor]:
        # TODO: use all_gatherv
        all_topk_ids = get_dp_group().all_gather(topk_ids, dim=0)
        all_topk_weights = get_dp_group().all_gather(topk_weights, dim=0)

        # self.pp("ALL_TOPK_IDS", all_topk_ids)

        start = self.rank_expert_offset
        end = self.rank_expert_offset + self.num_local_experts

        # subtract? use oob expert idx?
        oob_idx = self.num_local_experts if self.rank_expert_offset == 0 else 0
        assert not (all_topk_ids == oob_idx).all()
        new_topk_ids = torch.where(
            (all_topk_ids >= start) & (all_topk_ids < end), all_topk_ids, oob_idx
        )
        new_topk_weights = torch.where(all_topk_ids != oob_idx, all_topk_weights, 0.0)

        mask = ~torch.all(new_topk_ids == oob_idx, dim=1)
        # self.pp("MASK", mask)
        new_topk_ids = new_topk_ids[mask]
        new_topk_weights = new_topk_weights[mask]

        # self.pp("NEW_TOPK_IDS_PRE", new_topk_ids)

        return new_topk_ids, new_topk_weights

    def prepare(
        self,
        a1: torch.Tensor,
        topk_weights: torch.Tensor,
        topk_ids: torch.Tensor,
        num_experts: int,
        expert_map: torch.Tensor | None,
        apply_router_weight_on_input: bool,
        quant_config: FusedMoEQuantConfig,
    ) -> mk.PrepareResultType:
        torch.set_printoptions(profile="full")

        if apply_router_weight_on_input:
            topk = topk_ids.size(1)
            # TODO: this only works for topK=1, will need to update for topK>1
            assert topk == 1, (
                "apply_router_weight_on_input is only implemented for topk=1"
            )
            a1 = a1 * topk_weights.to(a1.dtype)

        # Dispatch and Quant
        # DeepEP kernels only support dispatching block-quantized activation scales.
        # Dispatch in bfloat16 and quantize afterwards if not using block quantization.
        if quant_config.is_block_quantized:
            # Quant and Dispatch
            assert quant_config.block_shape == [128, 128]  # TODO: use constant
            a1q, a1q_scale = moe_kernel_quantize_input(
                a1,
                quant_config.a1_scale,
                quant_dtype=quant_config.quant_dtype,
                per_act_token_quant=quant_config.per_act_token_quant,
                block_shape=quant_config.block_shape,
            )
            if a1q_scale is not None and a1q_scale.numel() == 1:
                a1q_scale = a1q_scale.view(1, 1)
            a1_post_scale = None
        else:
            a1q = a1
            a1q_scale = None
            a1_post_scale = quant_config.a1_scale

        self.p(
            f"DISPATCH BEGIN[{self.rank_expert_offset}], a1q={a1q.shape} "
            f"a1q_s={a1q_scale.shape if a1q_scale is not None else None}"
        )
        self.pp("TOPK_IDS", topk_ids)
        # self.pp("TOPK_WEIGHTS", topk_weights)

        if False:
            M, K = a1.shape
            routing_map, probs = indices_to_map(topk_ids, topk_weights, M, num_experts)
            handle = self.construct_handle(K, M, num_experts, routing_map)
        else:
            routing_map = None
            probs = None
            handle = None

        self.pp("A1Q", a1q)

        (expert_x, expert_probs, expert_x_scale, handle) = self.buffer.dispatch(
            hidden=a1q,
            scaling_factor=a1q_scale,
            topk_idx=topk_ids,
            topk_weights=topk_weights,
            routing_map=routing_map,
            probs=probs,
            handle=handle,
            num_dispatched_tokens=None,
            num_of_experts=num_experts,
        )

        self.pp("EXPERT_X", expert_x)

        # (
        #     sparse_to_dense_map,
        #     rdma_to_attn_map,
        #     attn_to_rdma_map,
        #     num_of_tokens_for_experts,
        #     local_expert_routing_map,  #
        #     num_tokens,
        #     config,
        # ) = handle
        # self.pp("S2D", sparse_to_dense_map)
        # self.p(
        #     f"NUM_TOK_PER_EXPERT[{self.rank_expert_offset}]"
        #     f"={num_of_tokens_for_experts.item()}"
        # )
        # self.pp("LERM", local_expert_routing_map)

        self.handle = handle
        self.expert_probs = expert_probs  # TODO
        assert self.handle is not None

        self.pp("PROBS", self.expert_probs)
        self.p(
            f"DISPATCH END[{self.rank_expert_offset}], x={expert_x.shape} "
            f"x_s={expert_x_scale.shape if expert_x_scale is not None else None}"
        )

        new_topk_ids, new_topk_weights = self.create_new_topk_data(
            topk_ids,
            topk_weights,
        )

        assert new_topk_ids.shape[0] == expert_x.shape[0], (
            f"{new_topk_ids.shape} == {expert_x.shape}"
        )
        assert new_topk_ids.shape == new_topk_weights.shape, (
            f"{new_topk_ids.shape} == {new_topk_weights.shape}"
        )

        self.pp("NEW_TOPK_IDS", new_topk_ids)
        self.pp("NEW_TOPK_WEIGHTS", new_topk_weights)

        # Unused
        expert_tokens_meta = None

        if not quant_config.is_block_quantized and quant_config.quant_dtype is not None:
            # Quantize after dispatch.
            expert_x_scale = None
            if expert_x.numel() != 0:
                expert_x, expert_x_scale = moe_kernel_quantize_input(
                    expert_x,
                    a1_post_scale,
                    quant_dtype=quant_config.quant_dtype,
                    per_act_token_quant=quant_config.per_act_token_quant,
                    block_shape=quant_config.block_shape,
                )

        return (
            expert_x,
            expert_x_scale,
            expert_tokens_meta,
            new_topk_ids,
            new_topk_weights,
        )

    def finalize(
        self,
        output: torch.Tensor,
        fused_expert_output: torch.Tensor,
        topk_weights: torch.Tensor,
        topk_ids: torch.Tensor,
        apply_router_weight_on_input: bool,
        weight_and_reduce_impl: mk.TopKWeightAndReduce,
    ) -> None:
        self.p(
            f"COMBINE BEGIN[{self.rank_expert_offset}] "
            f"{fused_expert_output.dtype} out={output.shape} "
            f"fe_out={fused_expert_output.shape}"
        )

        # self.pp("FUSED_EXPERT_OUTPUT", fused_expert_output, True)

        combined_x, combined_probs = self.buffer.combine(
            hidden=fused_expert_output,
            # TODO: when weight_and_reduce_impl is delegate
            probs=None,  # self.expert_probs,
            handle=self.handle,
        )

        self.p(
            f"COMBINE END[{self.rank_expert_offset}] {combined_x.shape} "
            f"{combined_probs.shape if combined_probs is not None else None}"
        )

        # self.pp("COMBINED_X", combined_x, True)
        # self.pp("TOPK_IDS", topk_ids, True)
        # self.pp("TOPK_WEIGHTS", topk_weights, True)

        if isinstance(weight_and_reduce_impl, TopKWeightAndReduceDelegate):
            weight_and_reduce_impl = TopKWeightAndReduceContiguous()

        self.p(f"REDUCDER = {weight_and_reduce_impl}")

        weight_and_reduce_impl.apply(
            output=output,
            fused_expert_output=combined_x,
            topk_weights=topk_weights,
            topk_ids=topk_ids,
            apply_router_weight_on_input=apply_router_weight_on_input,
        )
